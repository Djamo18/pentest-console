#!/usr/bin/ruby

require 'rubygems'
require 'pp'
require 'xmlrpc/client'
require 'optparse'
require 'yaml' 
require 'base64' ## required for downloading attachments 
require 'cgi' ## HTML-Encoding

## hash for all the options
options = {}
options[:username] = ""
options[:password] = ""
options[:project] = ""
options[:server] = ""
options[:filename] = ""

## Get options from YAML
## 
CONFIG = YAML::load(File.read('/var/ptc/settings/options.yaml'))
options[:username] = CONFIG['settings']['username']
options[:password] = CONFIG['settings']['password']
options[:project] = CONFIG['settings']['project']
options[:server] = CONFIG['settings']['server']
options[:filename] = CONFIG['settings']['filename']

## Set up the option parser
optparse = OptionParser.new do|opts|
   opts.banner = "Usage: ticketgen.rb --user [user] --pass [pass] --project [project] --server [server] --filename [ticketfile]" 

   ## Gather command-line options
   opts.on('-h', '--help', 'Help Screen') do
      puts opts
      exit
   end
   
   opts.on('-v', '--verbose', 'Verbose Output') do
      options[:verbose] = true
      exit
   end

   opts.on('-u', '--user USER', String, 'Trac Username') do |username|
      options[:username]  = username
   end

   opts.on('-p', '--password PASSWORD', String, 'Trac Password') do |password|
      options[:password]  = password
   end  

   opts.on('-r', '--project PROJECT', String, 'Trac Project') do |project|
      options[:project]  = project
   end

   opts.on('-s', '--server SERVER', String, 'Trac Server') do |server|
      options[:server]  = server
   end
 
   opts.on('-f', '--filename FILENAME', String, 'Trac Tickets (filename)') do |filename|
      options[:filename] = filename
   end
end


# Parse the command-line. Remember there are two forms
# of the parse method. The 'parse' method simply parses
# ARGV, while the 'parse!' method parses ARGV and removes
# any options found there, as well as any parameters for
# the options. What's left is the list of files to resize.
optparse.parse!


## Gather interactively if not specified
if options[:username].to_s.empty? then
   puts "User:"
   options[:username] = gets
end

if options[:password].to_s.empty? then
   puts "Password:"
   options[:password] = gets
end

if options[:project].to_s.empty? then
   puts "Project:"
   options[:project] = gets
end

if options[:server].to_s.empty? then
   puts "Server:"
   options[:server] = gets
end

##if options[:filename].to_s.empty? then
##   puts "Filename:"
##   options[:filename] = gets
##end

## ensure we have strings
String username = options[:username]
String password = options[:password]
String server = options[:server]
String project = options[:project]


## remove newlines
username.chomp!
password.chomp!
server.chomp!
project.chomp!


def get_attachment(server, ticketnum, filename)
   ## call server method
   x = server.call("ticket.getAttachment", ticketnum, filename) ##returns the content of an attachment.

   return x
end

def get_attachments(server, ticketnum, project)
   someArray = server.call("ticket.listAttachments", ticketnum) ##Lists attachments for a given ticket.
   
   names = Array.new

   if (!someArray.empty?) then


     ## get this particular attachment 
     someArray.each { |attachment|
	
	## filename should be the first parameter
	filename = attachment[0]
         
         ## store this for xml
         names.push filename

         puts "getting " + filename + " for ticket " + ticketnum.to_s + "... \n"


	## get the attachment
	x = get_attachment(server, ticketnum, filename)

	puts "saving to disk...\n"

	## save the file	
 	Dir.mkdir(project + "/" + ticketnum.to_s) unless File.directory?(project + "/" + ticketnum.to_s)

	myfile = File.new(project + "/" + ticketnum.to_s + "/" + filename, "w+")
	myfile.write(x)
      }
   end

   return names
end

def filter_data(text)
	return CGI.escapeHTML(text)
end

=begin
def get_dread(server,ticketnum, project)
  
   ## get ticket
   results = server.call("ticket.get",ticketnum)

   ## get rating
   damagePotential = filter_data(results[3]["damagepotential"].to_s)
   reproducibility = filter_data(results[3]["reproducibility"].to_s)
   exploitability = filter_data(results[3]["exploitability"].to_s)
   affectedUsers = filter_data(results[3]["affectedusers"].to_s)
   discoverability = filter_data(results[3]["discoverability"].to_s)

   ## calculate dread total
   dreadTotal = damagePotential.to_i +
                reproducibility.to_i +
                exploitability.to_i +
                affectedUsers.to_i +
                discoverability.to_i

return dreadTotal
end
=end

def get_tickets(server,project)

   Dir.mkdir(project) unless File.directory?(project)

   x = server.call("ticket.query", "type=finding&status!=closed&order=priority")
   puts "no tickets" if x.empty?

   xml = "<?xml version='1.0' encoding='ISO-8859-1'?>" +  "\n"
   xml = xml + "<findings>\n"

   findings = Array.new

   ##x.sort {|a,b| a[1] <=> get_dread(server,b[1],project)}
   x.each { |ticketnum|
	findings.push get_finding_from_ticket(server, ticketnum, project) 
   }

   findings = findings.sort_by {|finding| -finding[:dreadTotal].to_i }

   findings.each { |finding| 
	print_finding(finding)
	xml = xml + get_finding_xml(finding,project) 
   }

   xml = xml + "</findings>\n"
   
   ticketfile = File.new(project + "/" + "findings.xml", "w+")
   ticketfile.write(xml)

return findings
end


def get_finding_from_ticket(server, ticketnum, project)
   # print the data
   results = server.call("ticket.get",ticketnum)

   finding = {}

   ## get the shiz 
   finding[:number] = filter_data(ticketnum.to_s)
   finding[:title] = filter_data(results[3]["summary"].to_s) ## or something?
   finding[:reporter] = filter_data(results[3]["reporter"].to_s)
   finding[:owner] = filter_data(results[3]["owner"].to_s)
   finding[:description] = filter_data(results[3]["description"].to_s)
   finding[:affects] = filter_data(results[3]["affects"].to_s)
   finding[:type] = filter_data(results[3]["type"].to_s)
   finding[:status] = filter_data(results[3]["status"].to_s)
   finding[:priority] = filter_data(results[3]["priority"].to_s)
   finding[:milestone] = filter_data(results[3]["milestone"].to_s)
   finding[:component] = filter_data(results[3]["component"].to_s)
   finding[:version] = filter_data(results[3]["version"].to_s)
   finding[:resolution] = filter_data(results[3]["resolution"].to_s)
   finding[:keywords] = filter_data(results[3]["keywords"].to_s)
   finding[:ccname] = filter_data(results[3]["ccname"].to_s)
   finding[:templatefinding] = filter_data(results[3]["templatefinding"].to_s)
   finding[:damagePotential] = filter_data(results[3]["damagepotential"].to_s)
   finding[:reproducibility] = filter_data(results[3]["reproducibility"].to_s)
   finding[:exploitability] = filter_data(results[3]["exploitability"].to_s)
   finding[:affectedUsers] = filter_data(results[3]["affectedusers"].to_s)
   finding[:discoverability] = filter_data(results[3]["discoverability"].to_s)
   finding[:proof] = filter_data(results[3]["proof"].to_s)
   finding[:recommendations] = filter_data(results[3]["recommendations"].to_s)
   finding[:references] = filter_data(results[3]["references"].to_s)
   finding[:remediationEffort] = filter_data("undefined")

   ## iterate through attachments
   ##finding[:attachments] = Array.new
   finding[:attachments] = get_attachments(server,ticketnum,project)

   ## calculate dread total
   dreadTotal = finding[:damagePotential].to_i + 
		finding[:reproducibility].to_i + 
		finding[:exploitability].to_i + 
		finding[:affectedUsers].to_i + 
		finding[:discoverability].to_i

   ## calculate dread risk
   dreadRisk = "undefined"
   if (dreadTotal > 40) then
        dreadRisk = "Critical"
   elsif (dreadTotal > 29)  
        dreadRisk = "Severe"
   elsif (dreadTotal > 10)
        dreadRisk = "Moderate"
   else
        dreadRisk = "Low"
   end

   finding[:dreadTotal] = dreadTotal
   finding[:dreadRisk] = dreadRisk

return finding
end


def print_finding(finding)
   ticket_matrix_string = 
	finding[:number].to_s + "," +
       	finding[:component] + "," +
       	finding[:title] + "," +
        	finding[:damagePotential] + "," +
       	finding[:reproducibility] + "," +
       	finding[:exploitability] + "," +
       	finding[:affectedUsers] + "," +
        	finding[:discoverability] + "," +
        	finding[:dreadTotal].to_s + "," +
        	finding[:dreadRisk]

   puts ticket_matrix_string + "\n"
end

def get_finding_xml(finding,project)
   ticket_matrix_string = 
	finding[:number].to_s + "," +
       	finding[:component] + "," +
       	finding[:title] + "," +
       	finding[:damagePotential] + "," +
       	finding[:reproducibility] + "," +
       	finding[:exploitability] + "," +
       	finding[:affectedUsers] + "," +
       	finding[:discoverability] + "," +
       	finding[:dreadTotal].to_s + "," +
       	finding[:dreadRisk]

   ## save the ticket to the matrix file
   myfile = File.new(project + "/ticket_matrix.csv", "a")
   myfile.write(ticket_matrix_string + "\n")

   ## create finding directory
   Dir.mkdir(project + "/" + finding[:number].to_s) unless File.directory?(project + "/" + finding[:number].to_s)

   ## create XML
   ##finding_xml = "<?xml version='1.0' encoding='ISO-8859-1'?>" +  "\n"
   finding_xml = "   <finding number=\"" + finding[:number].to_s + "\">" +  "\n"
   finding_xml = finding_xml + "      <title>" + finding[:title] + "</title>" + "\n"
   finding_xml = finding_xml + "      <status>"  + "verified" + "</status>" + "\n"
   finding_xml = finding_xml + "      <rating>" + "\n"
   finding_xml = finding_xml + "         <dread>" + "\n"
   finding_xml = finding_xml + "            <discoverability>" + finding[:discoverability] + "</discoverability>" + "\n"
   finding_xml = finding_xml + "            <reproducibility>" + finding[:reproducibility] + "</reproducibility>" + "\n"
   finding_xml = finding_xml + "            <exploitability>" + finding[:exploitability] + "</exploitability>" + "\n"
   finding_xml = finding_xml + "            <affectedusers>" + finding[:affectedUsers] + "</affectedusers>" + "\n"
   finding_xml = finding_xml + "            <damagepotential>" + finding[:damagePotential] + "</damagepotential>" + "\n"
   finding_xml = finding_xml + "            <dreadtotal>" + finding[:dreadTotal].to_s + "</dreadtotal>" + "\n"
   finding_xml = finding_xml + "            <dreadrisk>" + finding[:dreadRisk] + "</dreadrisk>" + "\n"
   finding_xml = finding_xml + "         </dread>" + "\n"
   finding_xml = finding_xml + "         <remediationeffort>" + finding[:remediationEffort] + "</remediationeffort>" + "\n"
   finding_xml = finding_xml + "      </rating>" + "\n"
   finding_xml = finding_xml + "      <affects>" +  finding[:affects] + "</affects>" + "\n"

   ##finding_xml = finding_xml + "      <prerequisites>" + "\n"
   ## iterate thru prerequisites
   ##   finding_xml = finding_xml + "         <prerequisite> " + prerequsite[x] + "</prerequsite>" + "\n"
   ##finding_xml = finding_xml + "      </prerequisites>" + "\n"

   finding_xml = finding_xml + "      <description>" + finding[:description] + "</description>" + "\n"
   finding_xml = finding_xml + "      <proof>" + finding[:proof] + "</proof>" + "\n"
   finding_xml = finding_xml + "      <recommendations>" + finding[:recommendations] + "</recommendations>" + "\n"
   finding_xml = finding_xml + "      <references>" + finding[:references] + "</references>" + "\n"
   finding_xml = finding_xml + "      <attachments>" + "\n"
   if (!finding[:attachments].empty?) then    ## iterate thru attachments
     finding[:attachments].each { |attachment|
        finding_xml = finding_xml + "         <attachment>" + attachment + "</attachment>" + "\n"
     }
   end
   finding_xml = finding_xml + "      </attachments> " + "\n"
   finding_xml = finding_xml + "   </finding>" + "\n"


   ## if we're doing singles:
   single_finding_xml = "<findings>\n" + finding_xml
   single_finding_xml = single_finding_xml + "</findings>"
   
   ## Create a directory for this file
   ##Dir.mkdir(project + "/" + finding[:number].to_s) unless File.directory?(project + "/" + finding[:number])

   ## save the file	
   myfile = File.new(project + "/" + finding[:number].to_s + "/" + "finding.xml", "w+")
   myfile.write(single_finding_xml)

  return finding_xml
end

## construct the project url
url = "https://" + username + ":" + password + "\@" + server + "/projects/" + project + "/xmlrpc"

puts url

# initialize the connection (username and password can be ommitted if not needed, but most of the time you will need them if anonymous doesn't have XMLRPC permissions)
server = XMLRPC::Client::new2(url)
get_tickets(server,project)

puts "end.\n"
