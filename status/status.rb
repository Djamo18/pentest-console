#!/usr/bin/ruby

require 'rubygems'
require 'pp'
require 'xmlrpc/client'
require 'optparse'
require 'yaml' 
require 'base64' ## required for downloading attachments 


## hash for all the options
options = {}
options[:username] = ""
options[:password] = ""
options[:project] = ""
options[:server] = ""
options[:protocol] = ""
options[:filename] = ""

## Get options from YAML
## 
CONFIG = YAML::load(File.read('/var/ptc/settings/options.yaml'))
options[:username] = CONFIG['settings']['username']
options[:password] = CONFIG['settings']['password']
options[:project] = CONFIG['settings']['project']
options[:server] = CONFIG['settings']['server']
options[:protocol] = CONFIG['settings']['protocol']
options[:filename] = CONFIG['settings']['filename']

## Set up the option parser
optparse = OptionParser.new do|opts|
   opts.banner = "Usage: ticketgen.rb --user [user] --pass [pass] --project [project] --server [server] --filename [ticketfile] --protocol [protocol]" 

   ## Gather command-line options
   opts.on('-h', '--help', 'Help Screen') do
      puts opts
      exit
   end
   
   opts.on('-v', '--verbose', 'Verbose Output') do
      options[:verbose] = true
      exit
   end

   opts.on('-u', '--user USER', String, 'Trac Username') do |username|
      options[:username]  = username
   end

   opts.on('-p', '--password PASSWORD', String, 'Trac Password') do |password|
      options[:password]  = password
   end  

   opts.on('-r', '--project PROJECT', String, 'Trac Project') do |project|
      options[:project]  = project
   end

   opts.on('-s', '--server SERVER', String, 'Trac Server') do |server|
      options[:server]  = server
   end

   opts.on('-p', '--protocol PROTOCOL', String, 'HTTP or HTTPS?') do |server|
      options[:server]  = server
   end

   opts.on('-t', '--type TICKETTYPE', String, 'Trac Ticket Type') do |type|
      options[:type] = type
   end 

   opts.on('-f', '--filename FILENAME', String, 'Trac Tickets (filename)') do |filename|
      options[:filename] = filename
   end

end


# Parse the command-line. Remember there are two forms
# of the parse method. The 'parse' method simply parses
# ARGV, while the 'parse!' method parses ARGV and removes
# any options found there, as well as any parameters for
# the options. What's left is the list of files to resize.
optparse.parse!


## Gather interactively if not specified
if options[:username].to_s.empty? then
   puts "User:"
   options[:username] = gets
end

if options[:password].to_s.empty? then
   puts "Password:"
   options[:password] = gets
end

if options[:project].to_s.empty? then
   puts "Project:"
   options[:project] = gets
end

if options[:server].to_s.empty? then
   puts "Server:"
   options[:server] = gets
end

if options[:protocol].to_s.empty? then
   puts "Protocol:"
   options[:protocol] = gets
end

if options[:filename].to_s.empty? then
   puts "Filename:"
   options[:filename] = gets
end

if options[:type].to_s.empty? then
   puts "Type:"
   options[:type] = gets
end

## ensure we have strings
String username = options[:username]
String password = options[:password]
String server = options[:server]
String project = options[:project]
String protocol = options[:protocol]
String filename = options[:filename]
String type = options[:type]


## remove newlines
username.chomp!
password.chomp!
server.chomp!
project.chomp!
protocol.chomp!
filename.chomp!
type.chomp!


def get_ticket(server, ticketnum, project)
   # print the data
   results = server.call("ticket.get",ticketnum)

   ## get the shiz 
   title = results[3]["summary"].to_s ## or something?
   reporter = results[3]["reporter"].to_s
   owner = results[3]["owner"].to_s
   description = results[3]["description"].to_s
   type = results[3]["type"].to_s
   status = results[3]["status"].to_s
#   priority = results[3]["priority"].to_s
#   milestone = results[3]["milestone"].to_s
#   component = results[3]["component"].to_s
#   version = results[3]["version"].to_s
#   resolution = results[3]["resolution"].to_s
#   keywords = results[3]["keywords"].to_s
#   ccname = results[3]["ccname"].to_s
#   templatefinding = results[3]["templatefinding"].to_s
#   damagePotential = results[3]["damagepotential"].to_s
#   reproducibility = results[3]["reproducibility"].to_s
#   exploitability = results[3]["exploitability"].to_s
#   affectedUsers = results[3]["affectedusers"].to_s
#   discoverability = results[3]["discoverability"].to_s
#   proof = results[3]["proof"].to_s
#   recommendations = results[3]["recommendations"].to_s
#   references = results[3]["references"].to_s
#   remediationEffort = "undefined"
#   affects = "undefined"

   status_line = title + " " + status + " "

  return status_line
end

## construct the project url
url = protocol + "://" + username + ":" + password + "\@" + server + "/projects/" + project + "/xmlrpc"

##puts "DEBUG: URL: " + url + "\n\n\n"

# initialize the connection (username and password can be ommitted if not needed, but most of the time you will need them if anonymous doesn't have XMLRPC permissions)
server = XMLRPC::Client::new2(url)

puts "Completed:\n"
x = server.call("ticket.query", "type=" + type + "&status=closed")
puts "DEBUG: no tickets" if x.empty?
x.each { |ticketnum| puts get_ticket(server,ticketnum, project) }

puts "In Progress:\n"
x = server.call("ticket.query", "type=" + type + "&status!=closed")
puts "DEBUG: no tickets" if x.empty?
x.each { |ticketnum| puts get_ticket(server,ticketnum, project) }

puts "end.\n"
