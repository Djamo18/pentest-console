#!/usr/bin/ruby

##
## jcran - rapid7 - 2009 
##  (ptc) nexpose vulnerability parser 
##


require 'rubygems'
require 'nokogiri'
require 'xmlrpc/client'
require 'optparse'
require 'yaml' 

## 
## hash for all the options
options = {}
options[:username] = ""
options[:password] = ""
options[:project] = ""
options[:server] = ""
##options[:filename] = ""
options[:protocol] = ""

## Get options from YAML
## 
CONFIG = YAML::load(File.read('../../settings/options.yaml'))
options[:username] = CONFIG['settings']['username']
options[:password] = CONFIG['settings']['password']
options[:project] = CONFIG['settings']['project']
options[:server] = CONFIG['settings']['server']
##options[:filename] = CONFIG['settings']['filename']
options[:protocol] = CONFIG['settings']['protocol']


## Set up the option parser
optparse = OptionParser.new do|opts|
   opts.banner = "Usage: nexpose-parse-vuln.rb --user [user] --pass [pass] --project [project] --server [server] --filename [ticketfile]" 

   ## Gather command-line options
   opts.on('-h', '--help', 'Help Screen') do
      puts opts
      exit
   end
   
   opts.on('-v', '--verbose', 'Verbose Output') do
      options[:verbose] = true
      exit
   end

   opts.on('-u', '--user USER', String, 'Trac Username') do |username|
      options[:username]  = username
   end

   opts.on('-p', '--password PASSWORD', String, 'Trac Password') do |password|
      options[:password]  = password
   end  

   opts.on('-r', '--project PROJECT', String, 'Trac Project') do |project|
      options[:project]  = project
   end

   opts.on('-s', '--server SERVER', String, 'Trac Server') do |server|
      options[:server]  = server
   end
 
   opts.on('-f', '--filename FILENAME', String, 'Trac Tickets (filename)') do |filename|
      options[:filename] = filename
   end
end


# Parse the command-line. Remember there are two forms
# of the parse method. The 'parse' method simply parses
# ARGV, while the 'parse!' method parses ARGV and removes
# any options found there, as well as any parameters for
# the options. What's left is the list of files to resize.
optparse.parse!


## Gather interactively if not specified
if options[:username].to_s.empty? then
   puts "User:"
   options[:username] = gets
end

if options[:password].to_s.empty? then
   puts "Password:"
   options[:password] = gets
end

if options[:project].to_s.empty? then
   puts "Project:"
   options[:project] = gets
end

if options[:server].to_s.empty? then
   puts "Server:"
   options[:server] = gets
end

if options[:filename].to_s.empty? then
   puts "Filename:"
   options[:filename] = gets
end

if options[:protocol].to_s.empty? then
   puts "Protocol:"
   options[:protocol] = gets
end


## ensure we have strings
String username = options[:username]
String password = options[:password]
String server = options[:server]
String project = options[:project]
String filename = options[:filename]
String protocol = options[:protocol]


## remove newlines
username.chomp!
password.chomp!
server.chomp!
project.chomp!
filename.chomp!
protocol.chomp!


def add_new_finding(id,findings)
	print "DEBUG: " + "adding new finding " + id + "\n"

	findings[id] = create_finding(id)
end

def remove_finding(id,findings)
	pring "DEBUG: " + "removing finding " + id + "\n"
	findings[id] = nil
end

def create_finding(id)
	finding = Hash.new()
	finding[:id] = id
	finding[:title] = "undefined"
	finding[:description] = "undefined"
	finding[:affects] = "" # will be appended
	finding[:proof] = "" # will be appended
	finding[:recommendations] = "undefined"
	finding[:references] = "undefined"
	finding[:notes] = "" # will be appended
	finding[:discoverability] = 0
	finding[:reproducibility] = 0
	finding[:exploitability] = 0
	finding[:affectedusers] = 0
	finding[:damagepotential] = 0
return finding
end

def print_findings (findings)
	findings.each do |key,value|
		##print "DEBUG: " + "findings(key): " + key.to_s + "\n"
		print_finding_quick(value[:id],findings)
	end
end

def print_finding_count(findings)
	##print "DEBUG: " + "Findings:\n "
	print "-----------------------------------------\n"   
	print "Findings Count: " + findings.count + "\n"
	print "-----------------------------------------\n"
end

def print_finding_quick(id,findings)
	print "Finding: " + findings[id][:title].to_s + "\n" + findings[id][:affects].to_s + "\n"
	print "Proof:\n" + findings[id][:proof].to_s + "\n"
	print "\n"
end

def print_finding(id,findings)
	print "id:                " + id.to_s + "\n"
	print "affects:           " + findings[id][:affects].to_s + "\n"
	print "title:             " + findings[id][:title].to_s + "\n"
	print "description:\n     " + findings[id][:description].to_s + "\n"
	print "proof:\n           " + findings[id][:proof].to_s + "\n"
	print "recommendations:\n " + findings[id][:recommendations].to_s  + "\n"
	print "references:\n      " + findings[id][:references].to_s + "\n"
	print "notes\n            " + findings[id][:notes].to_s + "\n"
end

def ptc_construct_url(protocol,username,password,server,project)
	## construct the project url
	url = protocol + "://" + username + ":" + password + "\@" + server + "/projects/" + project
##	print "DEBUG: " + url + "\n"
return url
end

def ptc_create_finding_tickets (findings, server)
##	print "DEBUG: " + "Creating tickets from findings" + "\n"
	tickets = Array.new()

	findings.each do |key,value|
		tickets.push ptc_create_finding_ticket(value, server)
	end
return tickets
end

def ptc_create_finding_ticket (finding, server)
##	print "DEBUG: " + "Creating ticket from finding" + "\n"
	attributes = {}
	attributes["type"] = "finding"
	attributes["affects"] = finding[:affects]
	attributes["proof"] = finding[:proof]
	attributes["recommendations"] = finding[:recommendations]
	attributes["references"] = finding[:references]
	attributes["discoverability"] = finding[:discoverability]
	attributes["reproducibility"] = finding[:reproducibility]
	attributes["exploitability"] = finding[:exploitability]
	attributes["affectedusers"] = finding[:affectedusers]
	attributes["damagepotential"] = finding[:damagepotential]
	attributes["notes"] = finding[:notes]

	result = server.call("ticket.create",finding[:title].to_s,finding[:description].to_s,attributes,false)

return result
end

def ptc_create_connection(url)
	# initialize the connection (username and password can be ommitted if not needed, but most of the time you will need them if anonymous doesn't have XMLRPC permissions)
##	print "DEBUG: url: " + url.to_s + "\n"

	server = XMLRPC::Client::new2(url)
end

def get_reference_link (ref)
	referenceproviders = Hash.new("")
	referenceproviders["BID"] = "http://www.securityfocus.com/bid/" 
	referenceproviders["APPLE"] = "http://docs.info.apple.com/article.html?artnum="
	referenceproviders["CVE"] = "http://web.nvd.nist.gov/view/vuln/detail?vulnId="
	referenceproviders["SUN"] = "http://sunsolve.sun.com/search/document.do?assetkey="
	referenceproviders["SECTRACK"] = "http://securitytracker.com/id?"
	referenceproviders["SECUNIA"] = "http://secunia.com/advisories/"
	referenceproviders["URL"] = ""
	referenceproviders["XF"] = "http://xforce.iss.net/xforce/xfdb/"
	return "(" + ref + ") " + referenceproviders[ref]
end

def get_devices_with_status (doc,vulnerability,type,findings)
	print "DEBUG: " + "getting devices with " + vulnerability + "\n"
	get_nodes_with_status(doc,vulnerability,type,findings)
	get_endpoints_with_status(doc,vulnerability,type,findings)
end

## find the specfics from the definition of 'vulnerability' in the xml and add them to 'findinigs'
def get_vulnerability_specifics (doc,vulnerability,findings)
	vulndef = Nokogiri::XML.parse(doc.xpath("/NexposeReport/VulnerabilityDefinitions/vulnerability[@id='" + vulnerability + "']").to_xml)

	title = vulndef.xpath('vulnerability/@title')
	severity = vulndef.xpath('vulnerability/@severity')
	pciSeverity = vulndef.xpath('vulnerability/@pciSeverity')
	cvssScore = vulndef.xpath('vulnerability/@cvssScore')
	cvssVector = vulndef.xpath('vulnerability/@cvssVector')
	published = vulndef.xpath('vulnerability/@published')
	added = vulndef.xpath('vulnerability/@added')
	modified = vulndef.xpath('vulnerability/@modified')
	
	description = vulndef.xpath('vulnerability/description').collect(&:text)
	recommendations = vulndef.xpath('vulnerability/solution').collect(&:text)

	references = Array.new
	referencekeys = vulndef.xpath('vulnerability/references/reference/@source')
	referencevals = vulndef.xpath('vulnerability/references/reference').collect(&:text)

	for i in 0..referencekeys.length-1 do
		references.push(get_reference_link(referencekeys[i].to_s) + referencevals[i].to_s)
		## the correct way to deal with references, but doesn't make sense for tickets
##		findings[vulnerability][:references][referencekeys[i]] = get_reference_link(referencekeys[i].to_s) + referencevals[i].to_s
	end

	findings[vulnerability][:title] = title.to_s
	findings[vulnerability][:description] = description.to_s
	findings[vulnerability][:recommendations] = recommendations.to_s

	findings[vulnerability][:references] = ""
	references.each do |reference|
		##print "DEBUG: reference: " + reference + "\n"
		findings[vulnerability][:references] =  findings[vulnerability][:references] + "\n" + reference
	end

##	print "DEBUG: title: " + title.to_s + "\n"
##	print "DEBUG: description: " + description.to_s + "\n"
##	print "DEBUG: recommendations: " + recommendations.to_s + "\n"	
end

## Add the nodes specifics (to the findings hash) from the xml ('doc') - call for each instance of a particular vulnerability ('vulnerability')
def get_nodes_with_status (doc,vulnerability,type,findings)

	nodestring = "/NexposeReport/nodes/node/tests/test[@status='"+ type + "' and @id='" + vulnerability + "']/ancestor::node"

	vulnerable_nodes = doc.xpath(nodestring) 
        vulnerableNodesAddress = vulnerable_nodes.xpath("./@address").to_a
        vulnerableNodesFingerprint = vulnerable_nodes.xpath("./fingerprints/os[1]/@product").to_a
	vulnerableNodesProof = vulnerable_nodes.xpath("./tests/test[@status='"+ type + "' and @id='" + vulnerability + "']").collect(&:text).to_a	
	if !vulnerableNodesAddress.empty? then
		print "DEBUG:  found " + vulnerableNodesAddress.count.to_s + " node instances.\n" 
		for i in (0..vulnerableNodesAddress.count - 1)
	##		print "DEBUG: Vulnerable Node: " + vulnerableNodesAddress[i].to_s + " " + vulnerableNodesFingerprint[i].to_s + "\n " + vulnerableNodesProof[i].to_s + "\n"
			findings[vulnerability][:affects] += vulnerableNodesAddress[i].to_s + "\n"
			findings[vulnerability][:notes] += vulnerableNodesFingerprint[i].to_s + "\n"
			findings[vulnerability][:proof] += vulnerableNodesProof[i].to_s + "\n"
		end
	end
end
	
## Add the endpoints specifics (to the findings hash) from the xml ('doc') - call for each instance of a particular vulnerability ('vulnerability')
def get_endpoints_with_status (doc,vulnerability,type,findings)
 	nodestring = "/NexposeReport/nodes/node/endpoints/endpoint/services/service/tests/test[@status='"+ type + "' and @id='" + vulnerability + "']/ancestor::node"
	endpointstring = "/NexposeReport/nodes/node/endpoints/endpoint/services/service/tests/test[@status='"+ type + "' and @id='" + vulnerability + "']/ancestor::endpoint"

	vulnerable_node = doc.xpath(nodestring)
	vulnerable_endpoint =  doc.xpath(endpointstring)

	vulnerableNodesAddress = vulnerable_node.xpath("./@address").to_a
	vulnerableEndpointPort = vulnerable_endpoint.xpath("./@port").to_a
	vulnerableEndpointService = vulnerable_endpoint.xpath("./services/service/@name").to_a
	vulnerableEndpointKey = vulnerable_endpoint.xpath("./services/service/@key").to_a
	vulnerableEndpointFingerprint = vulnerable_endpoint.xpath("./services/service/fingerprints").to_a
	vulnerableEndpointConfiguration = vulnerable_endpoint.xpath("./services/service/configuration").to_a
	vulnerableEndpointProof = vulnerable_endpoint.xpath("./services/service/tests/test[@status='"+ type + "' and @id='" + vulnerability + "']").collect(&:text).to_a

	if !vulnerableNodesAddress.empty? then
		print "DEBUG:  found " + vulnerableNodesAddress.count.to_s + " endpoint instances.\n" 
		for i in (0..vulnerableNodesAddress.count - 1)
##			print "DEBUG: Vulnerable Endpoint: " + vulnerableNodesAddress[i].to_s + " " + vulnerableEndpointPort[i].to_s + " " + vulnerableEndpointService[i].to_s + "\n"

			#  Not sure this applies - TODO
			findings[vulnerability][:notes] += vulnerableEndpointFingerprint[i].to_s + "\n\n"
			findings[vulnerability][:notes] += vulnerableEndpointConfiguration[i].to_s + "\n\n"
			findings[vulnerability][:affects] += vulnerableNodesAddress[i].to_s + ":" + vulnerableEndpointPort[i].to_s + " " + vulnerableEndpointKey[i].to_s + " (" + vulnerableEndpointService[i].to_s + ")\n"
			findings[vulnerability][:proof] += vulnerableEndpointProof[i].to_s + "\n"
		end
	end
end
	
## Return 'true' if the nexpose XML actually contains a particular vulnerability
def type_found (doc, vulnerability, type)
	nodestring = "/NexposeReport/nodes/node/tests/test[@status='"+ type + "' and @id='" + vulnerability + "']"
	endpointstring = "/NexposeReport/nodes/node/endpoints/endpoint/services/service/tests/test[@status='"+ type + "' and @id='" + vulnerability + "']"

	nodes = doc.xpath(nodestring)
	endpoints = doc.xpath(endpointstring)

## 	print "DEBUG: nodestring:\n " + doc.xpath(nodestring).to_s + "\n"
##	print "DEBUG: endpointstring:\n " + doc.xpath(endpointstring).to_s + "\n"
	
##	print "DEBUG: nodes empty: " + nodes.empty?.to_s + "\n"
##	print "DEBUG: endpoints empty: " + endpoints.empty?.to_s + "\n"

	if (!(nodes.empty?) or !(endpoints.empty?)) then
##		print "DEBUG: vulns found\n"
		return true
	end
return false
end

url = ptc_construct_url(protocol,username,password,server,project)
server = ptc_create_connection(url + "/xmlrpc")

puts "parsing ... " + filename + "\n";

if (filename == "") then
   puts "need a filename.\n" 
   quit;
end

doc = Nokogiri::XML.parse(File.read(filename))

vulnerabilities = doc.xpath("/NexposeReport/VulnerabilityDefinitions/vulnerability/@id")
findings = Hash.new()

vulnerabilities.each do | vulnerability |
##	print "DEBUG: vulnerability: " + vulnerability.to_s + "\n"

	if (type_found(doc,vulnerability, "vulnerable-exploited")) then
		add_new_finding(vulnerability,findings)
		get_vulnerability_specifics(doc,vulnerability,findings);
		get_devices_with_status(doc,vulnerability,"vulnerable-exploited",findings);
	end

##	get_devices_with_status(doc,vulnerability,"vulnerable-version", findings);
##	get_devices_with_status(doc,vulnerability,"skipped-disabled", findings);
##	get_devices_with_status(doc,vulnerability,"skipped-version", findings);
##	get_devices_with_status(doc,vulnerability,"not-vulnerable", findings);
##	get_devices_with_status(doc,vulnerability,"error",findings, findings);	

end

## print'm, if necessary
print_findings(findings)

## now, create tickets
x = ptc_create_finding_tickets(findings, server)

x.each do |ticket|
	print "DEBUG: created ticket: " + ticket.to_s + "\n"
end
